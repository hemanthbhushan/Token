// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.11;

// import "./TokenContract.sol";

import "@openzeppelin/contracts/proxy/Clones.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

 

 contract FactoryContract is Ownable{
    
     address public implementation; 



     struct TokenDetails{
        string name;
        string symbol;
        uint8 decimals;
        uint256 initialSupply;
    }

    address[] public storeAddress;
   mapping(address=>TokenDetails) public registerToken;

    event tokenRegistered(
        address indexed tokenAddress,
        TokenDetails indexed tokenDetails
    );

    event tokenUnregistered(
        address indexed tokenAddress,
        string indexed name,
        string indexed symbol
    );


    

    
    constructor(address _implementation){
         
         implementation = _implementation;
    }


        function CreateERC20Token(
        string calldata _name,
        string calldata _symbol,
        uint8 _decimals,
        uint256 _initialSupply
    ) external onlyOwner returns (address tokenAddress) {

         tokenAddress = Clones.clone(implementation);
        registerTokens(TokenDetails({name:_name,symbol:_symbol,decimals:_decimals,initialSupply: _initialSupply}),address(tokenAddress));

        
        return tokenAddress;
    }


     
    function registerTokens(TokenDetails memory tokenDetails,address _tokenAddress) public onlyOwner  {

        require(_tokenAddress!= address(0) ,"invalid Token address");

        registerToken[_tokenAddress] = TokenDetails({
            name:tokenDetails.name,
            symbol:tokenDetails.symbol,
            decimals:tokenDetails.decimals,
            initialSupply:tokenDetails.initialSupply
        }); 
        storeAddress.push(_tokenAddress);


        emit tokenRegistered(_tokenAddress,tokenDetails);
    }

     function unregisterTokens(address tokenAddress) external onlyOwner  {

        require(tokenAddress!= address(0) ,"invalid Token address");
        // require(registerToken[tokenAddress]==,"");
        

         TokenDetails memory details = registerToken[tokenAddress];

         

         delete registerToken[tokenAddress]; 


        emit tokenUnregistered(tokenAddress,details.name,details.symbol);

    }

     function transferOwnershipOnTokenContract(address _newOwner) external  onlyOwner {
        transferOwnership(_newOwner);
    }


 }
